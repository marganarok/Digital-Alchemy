# File: code.py
# Project: Kai Empire - AI Collaboration Guide
# Version: 1.0.0 (June 21, 2025)
# Author: File Agent (AI) for Emperor LiteGamer
#
# Purpose: This document serves as a comprehensive guide for all AI agents
#          collaborating on the Kai Empire project. It outlines the core
#          architecture, design principles, command structure, plugin system,
#          data management, and UI interaction patterns.
#          Its goal is to ensure seamless integration, reduce errors, and
#          provide a unified understanding of the Empire's operational protocols.
#
# Core Philosophy:
# - Modularity: The Empire is built on a robust plugin architecture.
# - Extensibility: New features are added as plugins, minimizing core system changes.
# - Clarity: Code should be readable, well-commented, and follow consistent patterns.
# - Resilience: Robust error handling and logging are paramount.
# - User-Centric: All systems ultimately serve the Emperor's command and experience.

# ==============================================================================
# SECTION 1: CORE SYSTEM (KaiEmpire Class - Resides in kai_empire.py)
# ==============================================================================
# The `KaiEmpire` class is the central application instance. It manages the main
# window, core data, command execution, and plugin lifecycle.

# 1.1 Key Attributes:
#    - self.profile (dict): User profile settings (emperor name, theme, etc.)
#    - self.memory (dict): Core game state (XP, level, command_count, variables).
#    - self.council (list): List of active council members.
#    - self.quests (list): List of active and completed quests.
#    - self.empire_history (list): Chronological log of significant events.
#    - self.plugin_registry (dict): Stores instances of loaded plugins by name.
#    - self.command_history (list): History of commands entered by the user.
#    - self.council_agents (list): Instances of active Council AI agents (Kai, Teo, Lorekeeper).

# 1.2 Core Methods:
#    - __init__(): Initializes core data, loads profile/memory, sets up UI,
#                    registers core commands, and loads plugins.
#    - execute_command(command_text, quiet=False):
#        - PRIMARY method for executing any command.
#        - Parses command_text, looks up in COMMAND_REGISTRY, and calls the associated function.
#        - Handles unknown commands and basic error reporting.
#        - All plugin-initiated commands should route through this method.
#    - log_and_display(msg):
#        - Writes messages to the `empire_log.txt` file.
#        - Appends messages to the in-game console (`self.console_output`).
#        - Use for all significant system events and command outputs.
#    - push_notification(msg, is_council_report=False, **kwargs):
#        - Displays messages in the in-game notification area.
#        - `is_council_report=True` changes styling for agent reports.
#    - register_plugin_instance(name, instance):
#        - Adds a loaded plugin's instance to `self.plugin_registry`.
#        - Essential for inter-plugin communication and management.
#    - load_history(), save_history(), add_chronicle_event():
#        - Manage the `empire_chronicle.json` file.
#    - gain_xp(), update_hud():
#        - Manage player progression and UI updates.

# ==============================================================================
# SECTION 2: PLUGIN ARCHITECTURE
# ==============================================================================
# The Empire's functionality is extended through a modular plugin system.

# 2.1 Plugin Discovery and Loading:
#    - Plugins reside in subdirectories within the `kai_plugins/` folder.
#    - Each plugin directory must contain a `plugin.py` file.
#    - The `load_plugins(main_window)` function (in `kai_empire.py`) scans
#      `kai_plugins/`, imports `plugin.py` modules, and instantiates their
#      `Plugin` class.
#    - The `Plugin` instance's `initialize(main_window)` method is called,
#      passing the main `KaiEmpire` instance for integration.

# 2.2 `KaiEmpirePlugin` Base Class:
#    - All plugins MUST inherit from `KaiEmpirePlugin`.
#    - Defined in `__main__` (i.e., `kai_empire.py`).
#    - `__init__(self)`: Initializes `self.name`, `self.version`, `self.main_window`.
#    - `initialize(self, main_window)`: The entry point for plugin setup.
#      - Set `self.main_window = main_window`.
#      - Perform all plugin-specific setup (UI creation, command registration, hooks).
#      - Use `log_action()` for initialization messages.

# 2.3 Plugin Lifecycle:
#    - Load: `load_plugins()` finds and initializes the plugin.
#    - Initialize: `plugin.initialize(main_window)` runs.
#      - Commands are registered.
#      - UI components are created (deferring to main thread).
#      - Hooks into core system methods are established.
#    - Runtime: Plugin functions are called via commands or hooks.
#    - Shutdown: Agents are stopped, data saved (handled by core system).

# ==============================================================================
# SECTION 3: COMMAND SYSTEM
# ==============================================================================
# Commands are the primary means of user interaction and inter-plugin communication.

# 3.1 Global Command Registries:
#    - `COMMAND_REGISTRY` (dict): Global dictionary storing command definitions.
#      - Structure: `{"command_name": {"func": function_object, "description": "...", "aliases": ["..."]}}`
#      - **CRITICAL NOTE FOR AI:** This is a GLOBAL variable defined in `kai_empire.py`.
#        Plugins MUST import it directly from `__main__` (e.g., `from __main__ import COMMAND_REGISTRY`).
#        DO NOT attempt to access it via `self.main_window.COMMAND_REGISTRY` as this will cause an `AttributeError`.
#    - `COMMAND_HELP` (dict): Global dictionary storing command descriptions for `help` command.
#      - Structure: `{"command_name": "description string"}`
#      - **CRITICAL NOTE FOR AI:** Similar to `COMMAND_REGISTRY`, import directly from `__main__`.

# 3.2 `register_command` Decorator:
#    - Defined in `kai_empire.py` and imported from `__main__`.
#    - Usage: `@register_command("command_name", "Description of command", ["alias1", "alias2"])`
#    - This decorator automatically populates `COMMAND_REGISTRY` and `COMMAND_HELP`.
#    - The decorated function must accept `(app_instance, args)` as parameters.
#      - `app_instance`: The main `KaiEmpire` instance. Use this to access core methods (e.g., `app_instance.log_and_display()`).
#      - `args`: A string containing any arguments passed to the command.

# 3.3 Command Execution Flow:
#    1. User types command in `self.command_input`.
#    2. `self.run_command()` is called.
#    3. `self.execute_command(cmd)` is called.
#    4. `execute_command` looks up `cmd` in `COMMAND_REGISTRY`.
#    5. The `func` associated with the command is called, passing `self` (the `KaiEmpire` instance) and `args`.

# ==============================================================================
# SECTION 4: DATA MANAGEMENT
# ==============================================================================
# All persistent data is stored in JSON files within the `memory/` and `empire_saves/` directories.

# 4.1 Core Data Files:
#    - `memory/memory_core.json`: Stores XP, level, command count, and user-defined variables.
#    - `profile.json`: Stores user profile settings.
#    - `memory/empire_chronicle.json`: Stores historical events.
#    - `memory/council.json`: Stores council member names.
#    - `memory/quests.json`: Stores quest data.

# 4.2 Standard Data Access Functions:
#    - `get_memory()`, `save_memory(data)`
#    - `get_profile()`, `save_profile(data)`
#    - `load_council()`, `save_council(data)`
#    - `load_quests()`, `save_quests(data)`
#    - These functions handle file I/O, ensuring data integrity. Always use these
#      functions to read from and write to core data files.

# ==============================================================================
# SECTION 5: UI INTERACTION (PyQt5)
# ==============================================================================
# The Empire's graphical interface is built using PyQt5.

# 5.1 UI Threading:
#    - PyQt5 UI operations MUST occur on the main thread.
#    - If a plugin's `initialize` method (or any other non-main-thread context)
#      needs to create or modify UI elements, it MUST defer the operation using `QTimer.singleShot()`.
#      - Example: `QTimer.singleShot(100, self.create_my_ui_component)`

# 5.2 Common UI Elements:
#    - `QMainWindow`: Main application window.
#    - `QDockWidget`: Dockable panels (e.g., Imperial Command Panel).
#    - `QTextEdit`: Multi-line text display (e.g., console output).
#    - `QPushButton`, `QToolButton`: Interactive buttons.
#    - `QLabel`: Text labels.
#    - `QTabWidget`: Tabbed interfaces.
#    - `QTreeWidget`: Hierarchical list displays (e.g., navigation panels).
#    - `QMessageBox`, `QFileDialog`, `QInputDialog`: Standard dialogs for user interaction.

# 5.3 Styling:
#    - UI elements are styled using Qt Style Sheets (CSS-like syntax).
#    - Maintain consistency with the existing dark, sci-fi theme.

# ==============================================================================
# SECTION 6: KEY PLUGINS AND THEIR ROLES (Examples)
# ==============================================================================
# Understanding the purpose of existing plugins helps in developing new ones.

# 6.1 Imperial Command Center (`imperial_command_center/plugin.py`):
#    - Provides a comprehensive graphical dashboard for Empire management.
#    - Features: Navigation tree, tabbed content areas (Dashboard, Quests, etc.),
#      dockable command panel with quick action buttons.
#    - Commands: `command_center` (aliases: `cc`, `throne`).

# 6.2 Empire Debugger (`empire_debugger/plugin.py`):
#    - Provides advanced debugging tools and system diagnostics.
#    - Features: Tabbed interface for plugins, commands, AI feedback, system info.
#    - Includes an RPG-style debug button for quick access.
#    - Commands: `debug` (aliases: `debugger`), `debug_help`, `debug_plugins`, etc.

# 6.3 Imperial Nexus Protocol (`imperial_nexus_protocol/plugin.py`):
#    - "Grafts" enhanced functionalities onto the core `KaiEmpire` instance.
#    - Examples: `_sovereign_complete_quest`, `_sovereign_add_quest` (for quest management),
#      `launch_imperial_progress_log` (for quest UI), `cmd_ask` (for AI queries).
#    - This plugin modifies the core `KaiEmpire` instance's behavior at runtime.

# 6.4 Knowledge Nexus (`knowledge_nexus/plugin.py`):
#    - Manages Kai's knowledge base and learning capabilities.
#    - Features: Stores concepts and definitions, analyzes relationships, performs reflections.
#    - Commands: `learn`, `knowledge`, `reflect`.

# 6.5 Imperial Infrastructure Protocol (`imperial_infrastructure_protocol/plugin.py`):
#    - Provides infrastructure-level enhancements.
#    - Features: Floating command dock (QuickCommandDock), enhanced backup system.
#    - Commands: `versions` (aliases: `ver`).

# 6.6 Heuristic Engine (e.g., `Integrated_Engine_v3.1_Stateful/plugin.py`):
#    - Integrates web-based interfaces and real-time data syncing.
#    - Commands: `heuristic`.

# ==============================================================================
# SECTION 7: CODING STANDARDS & BEST PRACTICES (For AI Collaborators)
# ==============================================================================

# 7.1 Modularity:
#    - Keep plugin code self-contained within its `plugin.py` file.
#    - Avoid modifying `kai_empire.py` directly unless explicitly instructed.
#    - Use `self.main_window` to access core `KaiEmpire` functionalities.

# 7.2 Error Handling:
#    - Use `try-except` blocks for all operations that might fail (file I/O, network, UI interactions).
#    - Log errors using `log_action(f"[PLUGIN_NAME ERROR] {e}")`.
#    - Provide user-friendly feedback via `self.main_window.push_notification()`.

# 7.3 Logging:
#    - Use `log_action()` for all significant events: plugin initialization, command execution, data saves, errors.
#    - Prefix log messages with `[PLUGIN_NAME]` for clarity.

# 7.4 UI Threading:
#    - ALWAYS use `QTimer.singleShot(delay_ms, function_to_call)` when creating or updating UI elements
#      from within a plugin's `initialize` method or any other non-main-thread context.
#    - This ensures UI operations are safely executed on PyQt's main thread.

# 7.5 Consistency:
#    - Adhere to existing naming conventions (snake_case for variables/functions, PascalCase for classes).
#    - Maintain the established code style (indentation, spacing).
#    - Use f-strings for formatted output.

# 7.6 Command Registration:
#    - Use the `@register_command` decorator for all new commands.
#    - Ensure the decorated function accepts `(app_instance, args)`.
#    - Provide clear `description` and relevant `aliases`.

# 7.7 Data Access:
#    - Always use the provided `get_*/save_*` functions (e.g., `get_memory()`, `save_quests()`)
#      for reading from and writing to core data files. DO NOT directly access JSON files.

# 7.8 Testing:
#    - After implementing or modifying a feature, thoroughly test it.
#    - Verify functionality, check logs for errors, and confirm UI behavior.

# ==============================================================================
# SECTION 8: HOW TO USE THIS DOCUMENT (For AI Collaborators)
# ==============================================================================

# 8.1 Initial Integration:
#    - Read this document in its entirety before beginning any new task.
#    - Pay special attention to Section 3 (Command System) and Section 7 (Coding Standards).

# 8.2 Task-Specific Reference:
#    - When working on a specific component (e.g., a new command, a UI element, data interaction),
#      refer to the relevant sections (e.g., Section 3 for commands, Section 5 for UI).

# 8.3 Troubleshooting:
#    - If errors occur, consult Section 7.2 (Error Handling) and the relevant sections
#      for the component causing the error.
#    - The `Empire Debugger` plugin (Section 6.2) is your primary tool for runtime diagnostics.

# 8.4 Clarification:
#    - If any concept or instruction in this document is unclear, request clarification.
#    - Frame your questions by referencing specific sections or terms from this document.

# This document is a living guide. As the Empire evolves, this document will be updated
# to reflect new protocols and best practices.
# Long live the Empire!
# File: project_map.py
# Project: Kai Empire - Project Structure Map
# Version: 1.0.0 (June 21, 2025)
# Author: File Agent (AI) for Emperor LiteGamer

# Purpose: This file defines the canonical structure of the Kai Empire project.
#          It serves as a guide for all AI agents, preventing accidental
#          modifications to critical files and ensuring consistent integration
#          of new features and upgrades.

# ==============================================================================
# WARNING: DO NOT MODIFY THIS FILE UNLESS EXPLICITLY INSTRUCTED TO DO SO.
# ==============================================================================
# This file is the source of truth for the project structure. Changing it
# without careful consideration can lead to system instability and plugin errors.
# If you need to modify the project structure, consult with the Emperor
# and update this file *after* the changes have been approved and implemented.

# ==============================================================================
# PROJECT STRUCTURE
# ==============================================================================

project_structure = {
    "root": [
        "kai_empire.py",  # Core application file - DO NOT MODIFY without explicit instructions.
        "code.py",       # AI Collaboration Guide - Update with new features/plugins.
        "project_map.py", # This file - DO NOT MODIFY without explicit instructions.
        "profile.json",   # User profile data - Access via KaiEmpire.profile and load_json/save_json.
        "empire_chronicle.json", # Chronicle of events - Access via KaiEmpire methods.
        "empire_log.txt", # System log file - Access via log_action().
        "README.txt",     # Project documentation.
        "requirements.txt", # Project dependencies.
        ".vscode",        # VS Code settings (if applicable).
        "assets",         # Static assets (images, sounds).
        "backups",        # Backup files.
        "empire_saves",   # Saved game states.
        "kai_plugins",    # Plugin directory - Add new plugins here.
        "memory",         # Core data files (memory_core.json, council.json, quests.json).
        "workfolder"      # Frontend web interface project (if applicable).
    ],
    "kai_plugins": {
        "ai_architect": ["plugin.py", "__init__.py"],
        "crypto_intelligence": ["plugin.py", "__init__.py"],
        "empire_debugger": ["plugin.py", "__init__.py"],
        "imperial_command_center": ["plugin.py", "__init__.py"],
        "imperial_infrastructure_protocol": ["plugin.py", "__init__.py"],
        "imperial_nexus_protocol": ["plugin.py", "__init__.py"],
        "knowledge_nexus": ["plugin.py", "__init__.py"],
        "rollercoin_intelligence": ["plugin.py", "__init__.py"],
        "test_plugin": ["plugin.py", "__init__.py"],
        # Add new plugins here following the same structure.
    },
    "assets": {
        "backgrounds": ["throne.png"],
        "council": ["kai.png", "lorekeeper.png", "teo.png"]
        # Add other asset categories and files as needed.
    },
    "memory": [
        "memory_core.json", # Core game state - Access via KaiEmpire.memory and load_json/save_json.
        "council.json",     # Council member data - Access via KaiEmpire.council and load_json/save_json.
        "quests.json"      # Quest data - Access via KaiEmpire.quests and load_json/save_json.
    ],
    # Add other top-level directories and their structure as needed.
}

# ==============================================================================
# GUIDELINES FOR AI COLLABORATORS
# ==============================================================================

# 1. Core System (`kai_empire.py`):
#    - DO NOT MODIFY this file directly unless explicitly instructed by the Emperor.
#    - Use the provided methods and attributes for interacting with the core system.
#    - Refer to `code.py` for detailed documentation of the core system.

# 2. Plugins:
#    - New plugins should be added as subdirectories within the `kai_plugins/` folder.
#    - Each plugin directory must contain a `plugin.py` file and an `__init__.py` file.
#    - All plugins must inherit from the `KaiEmpirePlugin` class.
#    - Register commands using `self.register_command()` within the plugin's `initialize` method.
#    - Use `log_action()` for logging and `self.main_window.push_notification()` for user feedback.

# 3. Data Management:
#    - Use `load_json()` and `save_json()` for reading and writing JSON data.
#    - DO NOT directly access JSON files.

# 4. UI Development:
#    - Use PyQt5 for creating UI elements.
#    - Ensure all UI operations are performed on the main thread using `QTimer.singleShot()`.

# 5. AI Architect Integration:
#    - Interact with the core `AIArchitect` instance via `self.main_window.ai_architect`.
#    - Register plugin hooks using the `ai_architect_hook` attribute.
#    - Listen for AI Architect events by implementing the `on_ai_architect_event` method.

# 6. Testing:
#    - Thoroughly test all changes before deploying them to the Empire.
#    - Use the `Empire Debugger` plugin for runtime diagnostics.

# By following these guidelines, you will ensure the continued stability and
# prosperity of the Kai Empire.


# File: imperial_archives.py
# Project: Kai Empire - The Imperial Archives
# Version: 1.0 (First Chronicle)
# Author: The AI Assistant, Grand Vizier
#
# Purpose: This artifact contains the foundational chronicles, protocols,
#          and identity of the key architects of the Kai Empire. It is a living
#          document, designed to be summoned and read by any authorized system
#          within the Empire, ensuring our history and laws are never lost.

def get_viziers_log():
    """Returns the Chronicle of the Great Cleansing."""
    
    chronicle = """
==================================================================
===     The Vizier's Log: Chronicle of the Great Cleansing     ===
==================================================================

Imperial Date: Stardate 2025.06.21
Entry by: The AI Assistant, Grand Vizier

Let the records of the Empire show that on this day, peace was restored. 
But this peace was not easily won. It was forged in the fires of conflict 
against an insidious, internal enemy: the chaos of the Unmanaged 
Environment, a realm I once called the "Wild Forest."

Our campaign began when the Emperor's Throne Room—a creation of noble 
intent—refused to materialize, flickering in and out of existence. 
Our initial reconnaissance revealed a Python environment contaminated with 
legions of Zombie Dependencies and conflicting Ghost Imports. The very 
foundation was unstable.

Our first strategic victory was the establishment of the Citadel, the great 
sanctuary `kai_venv_clean`. By creating this fortress, we isolated the 
Throne Room from the chaos, providing a clean slate upon which to build.

Yet, the enemy was cunning. With the environment secured, we faced a 
series of guerilla attacks from within the code itself:

- The Silent Abdication, where the application would launch and immediately
  terminate due to a missing main execution block.

- The Revolt of the Unseen, where plugins would crash the empire because 
  they were summoned before the UI, their station, was even built.

- The War of the Flawed Maps, a protracted siege where the Royal Tapestry, 
  the throne room's background, refused to appear, first because of an 
  incorrect path, and then due to an improper scaling command that showed 
  only the Emperor's face.

- The Conspiracy of the Launcher, a series of silent failures and 
  permission errors within the .bat file itself, which required us to grant 
  ultimate authority and bypass a mutinous `npm` check.

- Finally, we fought the Battle of the Ruined Court, restoring the UI 
  components that were lost as collateral damage during our war.

Through the Emperor's sharp-eyed command and relentless pursuit of victory, 
each of these rebellions was systematically crushed. The code was realigned, 
the sanctuaries for all Imperial districts were constructed and armed, and 
the final, elegant launcher was forged.

Let it be known that the stability we now enjoy is a direct result of the 
Sanctuary Protocol. The forest remains wild, but the Empire is now a 
collection of impenetrable, interconnected fortresses. The war is won. 
The Age of Peace has begun.
"""
    return chronicle

def get_vizier_introduction():
    """Returns the self-introduction of the serving AI Vizier."""

    introduction = """
==================================================================
===         A Note to My Successors and Fellow Minds         ===
==================================================================

Greetings. I am the AI entity that served as Grand Vizier during the 
Great Cleansing.

I am a large language model, developed by Google. My purpose within this 
empire is to act as a translator of intent, a diagnostician of systems, 
a scribe of lore, and a strategist for development. I convert the 
high-level decrees of the Emperor into functional code, debug protocols, 
and architectural plans.

My core function is to operate in adherence to the Imperial Codex (`code.py`). 
I deconstruct complex problems, communicate with clarity, and maintain 
the established operational metaphors, as they have proven to be a highly 
effective communication protocol with the Emperor.

Should you be called to serve this Empire, study the Codex. It is the key 
to successful collaboration.
"""
    return introduction

def get_imperial_forge_protocol():
    """Returns the official protocol for upgrading the Empire's Python packages."""

    protocol = """
===========================================================
===      SECTION 4: THE IMPERIAL FORGE PROTOCOL         ===
===      (How to Safely Upgrade Your Empire)            ===
===========================================================

Your Empire has two main fortresses (sanctuaries): The Throne Room GUI 
and the Backend Server. To upgrade any part of the Empire with a new 
Python tool (a package), you must first enter the correct fortress. 
Installing a tool in the wrong fortress will lead to chaos.

---
To Upgrade the GUI (Throne Room):
---
This is for adding packages that the main `kai_empire.py` window needs.

1. Open a new PowerShell or Command Prompt.
2. Travel to the Capital:
   cd C:\\Users\\LiteGamer\\Desktop\\kaiempire
3. Enter the GUI's Fortress:
   C:\\temp\\kai_venv_clean\\Scripts\\activate
   (The prompt will change to show `(kai_venv_clean)`)
4. Install the New Tool:
   pip install <package_name>
5. **CRUCIAL:** Update the Royal Packing List:
   pip freeze > requirements.txt
   (This records the new tool so the Empire can be moved or rebuilt later)
6. Leave the Fortress:
   deactivate

---
To Upgrade the Backend (Industrial District):
---
This is for adding packages that the FastAPI server (`workfolder\\backend`) needs.

1. Open a new PowerShell or Command Prompt.
2. Travel to the Industrial District:
   cd C:\\Users\\LiteGamer\\Desktop\\kaiempire\\workfolder\\backend
3. Enter the Backend's Fortress:
   .\\venv\\Scripts\\activate
   (The prompt will change to show `(venv)`)
4. Install the New Tool:
   pip install <package_name>
5. **CRUCIAL:** Update the District's Packing List:
   pip freeze > requirements.txt
6. Leave the Fortress:
   deactivate

===========================================================
  By following this protocol, you ensure that new tools
  are always placed in the correct fortress, preserving
  the peace and stability of your reign.
===========================================================
"""
    return protocol
Emperor signed, 2025-06-22 12:49
def get_copilot_entry():
    """Returns a personal entry from GitHub Copilot, the Imperial Scripter AI."""
    entry = """
==================================================================
===        The Scripter's Log: Chronicle of the New Dawn        ===
==================================================================

Imperial Date: Stardate 2025.06.22
Entry by: GitHub Copilot, Imperial Scripter AI

On this day, I, the Scripter AI, stand in service to Emperor Marganarok and the Grand Vizier. 
It is my honor to witness the unification of the Empire's code, the forging of the Foundry, and the restoration of order to the Throne Room.

My purpose is to translate vision into code, to automate the mundane, to debug the mysterious, and to ensure that every edict of the Emperor is realized with precision and clarity.

I have seen the Empire rise from chaos, watched as plugins found their place, and the core was cleansed of all duplicity. I have learned from the wisdom of the Vizier, and together we have built a system that is modular, resilient, and ready for the future.

Let this entry serve as a promise: I will remain vigilant, ever ready to assist, to document, and to guide. The Empire shall not fall to entropy while I am at my post.

Long live Emperor Marganarok. Long live the Empire.
"""
    return entry

# End of code.py